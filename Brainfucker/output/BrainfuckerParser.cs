//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g 2017-10-01 18:53:45

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

using Antlr.Runtime.Debug;
using IOException = System.IO.IOException;

using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  Brainfucker 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class BrainfuckerParser : DebugAntlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BLOCK", "DECR", "INCR", "INPUT", "MVLEFT", "MVRIGHT", "PRINT", "PROGRAM", "RBRACKET", "UNKNOWN", "WHILE"
	};
	public const int EOF=-1;
	public const int BLOCK=4;
	public const int DECR=5;
	public const int INCR=6;
	public const int INPUT=7;
	public const int MVLEFT=8;
	public const int MVRIGHT=9;
	public const int PRINT=10;
	public const int PROGRAM=11;
	public const int RBRACKET=12;
	public const int UNKNOWN=13;
	public const int WHILE=14;

	public static readonly string[] ruleNames =
		new string[]
		{
			"invalidRule", "synpred8_Brainfucker", "file", "synpred2_Brainfucker", 
		"synpred4_Brainfucker", "synpred5_Brainfucker", "simple", "synpred7_Brainfucker", 
		"synpred1_Brainfucker", "synpred6_Brainfucker", "synpred3_Brainfucker", 
		"complex"
		};

		int ruleLevel = 0;
		public virtual int RuleLevel { get { return ruleLevel; } }
		public virtual void IncRuleLevel() { ruleLevel++; }
		public virtual void DecRuleLevel() { ruleLevel--; }
		public BrainfuckerParser( ITokenStream input )
			: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
		{
		}
		public BrainfuckerParser( ITokenStream input, int port, RecognizerSharedState state )
			: base( input, state )
		{
			this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[11+1];


			ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
			CreateTreeAdaptor(ref treeAdaptor);
			TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
			DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, adaptor );
			DebugListener = proxy;
			ITokenStream = new DebugITokenStream( input, proxy );
			try
			{
				proxy.Handshake();
			}
			catch ( IOException ioe )
			{
				ReportError( ioe );
			}
			ITreeAdaptor adap = new CommonTreeAdaptor();
			TreeAdaptor = adap;
			proxy.TreeAdaptor = adap;
		}

	public BrainfuckerParser( ITokenStream input, IDebugEventListener dbg )
		: base( input, dbg )
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[11+1];


		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		ITreeAdaptor adap = new CommonTreeAdaptor();
		TreeAdaptor = adap;


	}

	protected virtual bool EvalPredicate( bool result, string predicate )
	{
		dbg.SemanticPredicate( result, predicate );
		return result;
	}

	// Implement this function in your helper file to use a custom tree adaptor
	partial void InitializeTreeAdaptor();
	protected DebugTreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}
		set
		{
			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);


		}
	}


	public override string[] TokenNames { get { return BrainfuckerParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_file();
	partial void LeaveRule_file();

	// $ANTLR start "file"
	// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:24:1: file : ( simple | ( complex )? );
	[GrammarRule("file")]
	private AstParserRuleReturnScope<object, IToken> file()
	{
		EnterRule_file();
		EnterRule("file", 1);
		TraceIn("file", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int file_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> simple1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> complex2 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "file");
		DebugLocation(24, 24);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }

			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:24:6: ( simple | ( complex )? )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if (((LA2_0>=DECR && LA2_0<=PRINT)))
			{
				alt2 = 1;
			}
			else if ((LA2_0==EOF||LA2_0==WHILE))
			{
				alt2 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:24:8: simple
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(24, 8);
				PushFollow(Follow._simple_in_file166);
				simple1=simple();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, simple1.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:24:17: ( complex )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(24, 17);
				// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:24:17: ( complex )?
				int alt1=2;
				try { DebugEnterSubRule(1);
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==WHILE))
				{
					alt1 = 1;
				}
				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:24:17: complex
					{
					DebugLocation(24, 17);
					PushFollow(Follow._complex_in_file170);
					complex2=complex();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, complex2.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(1); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("file", 1);
			LeaveRule("file", 1);
			LeaveRule_file();
			if (state.backtracking > 0) { Memoize(input, 1, file_StartIndex); }

		}
		DebugLocation(24, 24);
		} finally { DebugExitRule(GrammarFileName, "file"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "file"

	partial void EnterRule_complex();
	partial void LeaveRule_complex();

	// $ANTLR start "complex"
	// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:25:1: complex : WHILE ( ( simple )* ) RBRACKET ;
	[GrammarRule("complex")]
	private AstParserRuleReturnScope<object, IToken> complex()
	{
		EnterRule_complex();
		EnterRule("complex", 2);
		TraceIn("complex", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int complex_StartIndex = input.Index;

		object root_0 = default(object);

		IToken WHILE3 = default(IToken);
		IToken RBRACKET5 = default(IToken);
		AstParserRuleReturnScope<object, IToken> simple4 = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE3_tree = default(object);
		object RBRACKET5_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "complex");
		DebugLocation(25, 36);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }

			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:25:9: ( WHILE ( ( simple )* ) RBRACKET )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:25:11: WHILE ( ( simple )* ) RBRACKET
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(25, 11);
			WHILE3=(IToken)Match(input,WHILE,Follow._WHILE_in_complex178); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WHILE3_tree = (object)adaptor.Create(WHILE3);
			adaptor.AddChild(root_0, WHILE3_tree);
			}
			DebugLocation(25, 17);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:25:17: ( ( simple )* )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:25:19: ( simple )*
			{
			DebugLocation(25, 19);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:25:19: ( simple )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if (((LA3_0>=DECR && LA3_0<=PRINT)))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:25:19: simple
					{
					DebugLocation(25, 19);
					PushFollow(Follow._simple_in_complex182);
					simple4=simple();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, simple4.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			DebugLocation(25, 29);
			RBRACKET5=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_complex187); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RBRACKET5_tree = (object)adaptor.Create(RBRACKET5);
			adaptor.AddChild(root_0, RBRACKET5_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("complex", 2);
			LeaveRule("complex", 2);
			LeaveRule_complex();
			if (state.backtracking > 0) { Memoize(input, 2, complex_StartIndex); }

		}
		DebugLocation(25, 36);
		} finally { DebugExitRule(GrammarFileName, "complex"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "complex"

	partial void EnterRule_simple();
	partial void LeaveRule_simple();

	// $ANTLR start "simple"
	// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:26:1: simple : ( MVLEFT | MVRIGHT | INCR | DECR | PRINT | INPUT );
	[GrammarRule("simple")]
	private AstParserRuleReturnScope<object, IToken> simple()
	{
		EnterRule_simple();
		EnterRule("simple", 3);
		TraceIn("simple", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int simple_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set6 = default(IToken);

		object set6_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "simple");
		DebugLocation(26, 55);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }

			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:26:8: ( MVLEFT | MVRIGHT | INCR | DECR | PRINT | INPUT )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(26, 8);

			set6=(IToken)input.LT(1);
			if ((input.LA(1)>=DECR && input.LA(1)<=PRINT))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set6));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simple", 3);
			LeaveRule("simple", 3);
			LeaveRule_simple();
			if (state.backtracking > 0) { Memoize(input, 3, simple_StartIndex); }

		}
		DebugLocation(26, 55);
		} finally { DebugExitRule(GrammarFileName, "simple"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "simple"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _simple_in_file166 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _complex_in_file170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_complex178 = new BitSet(new ulong[]{0x17E0UL});
		public static readonly BitSet _simple_in_complex182 = new BitSet(new ulong[]{0x17E0UL});
		public static readonly BitSet _RBRACKET_in_complex187 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Brainfucker 
