//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g 2017-10-01 18:53:45

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  Brainfucker 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class BrainfuckerLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int BLOCK=4;
	public const int DECR=5;
	public const int INCR=6;
	public const int INPUT=7;
	public const int MVLEFT=8;
	public const int MVRIGHT=9;
	public const int PRINT=10;
	public const int PROGRAM=11;
	public const int RBRACKET=12;
	public const int UNKNOWN=13;
	public const int WHILE=14;

    // delegates
    // delegators

	public BrainfuckerLexer()
	{
		OnCreated();
	}

	public BrainfuckerLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public BrainfuckerLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_INPUT();
	partial void LeaveRule_INPUT();

	// $ANTLR start "INPUT"
	[GrammarRule("INPUT")]
	private void mINPUT()
	{
		EnterRule_INPUT();
		EnterRule("INPUT", 1);
		TraceIn("INPUT", 1);
		try
		{
			int _type = INPUT;
			int _channel = DefaultTokenChannel;
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:9:7: ( ',' )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:9:9: ','
			{
			DebugLocation(9, 9);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INPUT", 1);
			LeaveRule("INPUT", 1);
			LeaveRule_INPUT();
		}
	}
	// $ANTLR end "INPUT"

	partial void EnterRule_PRINT();
	partial void LeaveRule_PRINT();

	// $ANTLR start "PRINT"
	[GrammarRule("PRINT")]
	private void mPRINT()
	{
		EnterRule_PRINT();
		EnterRule("PRINT", 2);
		TraceIn("PRINT", 2);
		try
		{
			int _type = PRINT;
			int _channel = DefaultTokenChannel;
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:10:7: ( '.' )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:10:9: '.'
			{
			DebugLocation(10, 9);
			Match('.'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PRINT", 2);
			LeaveRule("PRINT", 2);
			LeaveRule_PRINT();
		}
	}
	// $ANTLR end "PRINT"

	partial void EnterRule_WHILE();
	partial void LeaveRule_WHILE();

	// $ANTLR start "WHILE"
	[GrammarRule("WHILE")]
	private void mWHILE()
	{
		EnterRule_WHILE();
		EnterRule("WHILE", 3);
		TraceIn("WHILE", 3);
		try
		{
			int _type = WHILE;
			int _channel = DefaultTokenChannel;
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:11:7: ( '[' )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:11:9: '['
			{
			DebugLocation(11, 9);
			Match('['); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHILE", 3);
			LeaveRule("WHILE", 3);
			LeaveRule_WHILE();
		}
	}
	// $ANTLR end "WHILE"

	partial void EnterRule_MVLEFT();
	partial void LeaveRule_MVLEFT();

	// $ANTLR start "MVLEFT"
	[GrammarRule("MVLEFT")]
	private void mMVLEFT()
	{
		EnterRule_MVLEFT();
		EnterRule("MVLEFT", 4);
		TraceIn("MVLEFT", 4);
		try
		{
			int _type = MVLEFT;
			int _channel = DefaultTokenChannel;
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:28:9: ( '<' )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:28:11: '<'
			{
			DebugLocation(28, 11);
			Match('<'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MVLEFT", 4);
			LeaveRule("MVLEFT", 4);
			LeaveRule_MVLEFT();
		}
	}
	// $ANTLR end "MVLEFT"

	partial void EnterRule_MVRIGHT();
	partial void LeaveRule_MVRIGHT();

	// $ANTLR start "MVRIGHT"
	[GrammarRule("MVRIGHT")]
	private void mMVRIGHT()
	{
		EnterRule_MVRIGHT();
		EnterRule("MVRIGHT", 5);
		TraceIn("MVRIGHT", 5);
		try
		{
			int _type = MVRIGHT;
			int _channel = DefaultTokenChannel;
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:29:9: ( '>' )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:29:11: '>'
			{
			DebugLocation(29, 11);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MVRIGHT", 5);
			LeaveRule("MVRIGHT", 5);
			LeaveRule_MVRIGHT();
		}
	}
	// $ANTLR end "MVRIGHT"

	partial void EnterRule_INCR();
	partial void LeaveRule_INCR();

	// $ANTLR start "INCR"
	[GrammarRule("INCR")]
	private void mINCR()
	{
		EnterRule_INCR();
		EnterRule("INCR", 6);
		TraceIn("INCR", 6);
		try
		{
			int _type = INCR;
			int _channel = DefaultTokenChannel;
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:30:6: ( '+' )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:30:8: '+'
			{
			DebugLocation(30, 8);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INCR", 6);
			LeaveRule("INCR", 6);
			LeaveRule_INCR();
		}
	}
	// $ANTLR end "INCR"

	partial void EnterRule_DECR();
	partial void LeaveRule_DECR();

	// $ANTLR start "DECR"
	[GrammarRule("DECR")]
	private void mDECR()
	{
		EnterRule_DECR();
		EnterRule("DECR", 7);
		TraceIn("DECR", 7);
		try
		{
			int _type = DECR;
			int _channel = DefaultTokenChannel;
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:31:6: ( '-' )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:31:8: '-'
			{
			DebugLocation(31, 8);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DECR", 7);
			LeaveRule("DECR", 7);
			LeaveRule_DECR();
		}
	}
	// $ANTLR end "DECR"

	partial void EnterRule_RBRACKET();
	partial void LeaveRule_RBRACKET();

	// $ANTLR start "RBRACKET"
	[GrammarRule("RBRACKET")]
	private void mRBRACKET()
	{
		EnterRule_RBRACKET();
		EnterRule("RBRACKET", 8);
		TraceIn("RBRACKET", 8);
		try
		{
			int _type = RBRACKET;
			int _channel = DefaultTokenChannel;
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:32:9: ( ']' )
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:32:11: ']'
			{
			DebugLocation(32, 11);
			Match(']'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RBRACKET", 8);
			LeaveRule("RBRACKET", 8);
			LeaveRule_RBRACKET();
		}
	}
	// $ANTLR end "RBRACKET"

	public override void mTokens()
	{
		// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:8: ( INPUT | PRINT | WHILE | MVLEFT | MVRIGHT | INCR | DECR | RBRACKET )
		int alt1=8;
		try { DebugEnterDecision(1, false);
		switch (input.LA(1))
		{
		case ',':
			{
			alt1 = 1;
			}
			break;
		case '.':
			{
			alt1 = 2;
			}
			break;
		case '[':
			{
			alt1 = 3;
			}
			break;
		case '<':
			{
			alt1 = 4;
			}
			break;
		case '>':
			{
			alt1 = 5;
			}
			break;
		case '+':
			{
			alt1 = 6;
			}
			break;
		case '-':
			{
			alt1 = 7;
			}
			break;
		case ']':
			{
			alt1 = 8;
			}
			break;
		default:
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}

		} finally { DebugExitDecision(1); }
		switch (alt1)
		{
		case 1:
			DebugEnterAlt(1);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:10: INPUT
			{
			DebugLocation(1, 10);
			mINPUT(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:16: PRINT
			{
			DebugLocation(1, 16);
			mPRINT(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:22: WHILE
			{
			DebugLocation(1, 22);
			mWHILE(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:28: MVLEFT
			{
			DebugLocation(1, 28);
			mMVLEFT(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:35: MVRIGHT
			{
			DebugLocation(1, 35);
			mMVRIGHT(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:43: INCR
			{
			DebugLocation(1, 43);
			mINCR(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:48: DECR
			{
			DebugLocation(1, 48);
			mDECR(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// D:\\Data\\Projects\\Brainfucker\\Brainfucker\\Brainfucker.g:1:53: RBRACKET
			{
			DebugLocation(1, 53);
			mRBRACKET(); 

			}
			break;

		}

	}


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

 
	#endregion

}

} // namespace  Brainfucker 
